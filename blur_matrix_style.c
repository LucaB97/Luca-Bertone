#include <stdio.h>
#include <stdlib.h>
#include <string.h>


#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) + \
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif




void generate_kernel (float * kernel_ptr , const int type , const int dimension , const float weight)
{
	switch (type) {
		case 0:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				kernel_ptr[i] = 1 / (float)(dimension*dimension)
;
			}
			break;
                
		case 1:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				if (i != (((dimension*dimension-1)/2)))
					kernel_ptr[i] = (1-weight)/(dimension*dimension-1);
				else
					kernel_ptr[i] = weight;
			}
	}
}




void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}




void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
        ((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}




void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;
}





int main(int argc , char **argv ) {


/* declarations */

int maxval , xsize , ysize , kernel_type , kernel_dimension , s; 

float kernel_weight;

float * kernel;

int print_from , print_to;


/* take inputs and generate the kernel */
if (argc > 2) {
	kernel_type = atoi ( *(argv + 1) );
	if (kernel_type == 0 | kernel_type == 1 | kernel_type == 2) {
		kernel_dimension = atoi ( *(argv + 2) );
		if (kernel_dimension % 2 == 0) {
			printf("The kernel dimension you entered is a even number (%d), but a odd number is required: %d + 1 = %d will be used.\n" , kernel_dimension , kernel_dimension , kernel_dimension + 1);
			++kernel_dimension; 
		}
		s = (kernel_dimension-1)/2; 
	}
	else { 
		printf("Admissable values for kernel type (first value to be entered) are: 0=mean kernel , 1=weighted kernel , 2=gaussian kernel\n");
		return 0;
	}
	
	if (kernel_type == 1) {
		if (argc > 3) {
			kernel_weight = atof ( *(argv+3) );
			if (kernel_weight < 0 | kernel_weight > 1) {
				printf("You entered a weight which is out of the range (0,1). The default value of 1/(kernel_dimension^2) will be used.\n");
				kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
			}
		}
		else {
			printf("You did not specify a weight for central element of the Weighted kernel. The default value of 1/(kernel_dimension^2) will be used.\n");
			kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
		}
	}

	kernel = (float *) calloc (kernel_dimension*kernel_dimension , sizeof(float) );
	generate_kernel (kernel , kernel_type , kernel_dimension , kernel_weight);

}
else {
	printf("You should enter at least two values: one for kernel type and one for its dimension.\n");

	return 0;
}



/* kernel: from pointer to matrix */

float kernel_matrix[kernel_dimension][kernel_dimension];

int k = 0;
for (int i = 0 ; i < kernel_dimension ; i++)
	for (int j = 0 ; j < kernel_dimension ; j++)
		kernel_matrix[i][j] = kernel[k++];



/* CHECK: print the kernel */

printf("\nKernel:\n");
for (int i = 0 ; i < kernel_dimension ; i++) {
	for (int j = 0 ; j < kernel_dimension ; j++) {
		printf("%.3f  " , kernel_matrix[i][j]);
        	if (j % kernel_dimension == kernel_dimension - 1)
            		printf("\n");
	}
}
printf("\n");



/* read the image */

unsigned short int * my_image;
void * my_pointer = &my_image;

read_pgm_image(my_pointer , &maxval , &xsize , &ysize , "check_me.pgm");

if ( I_M_LITTLE_ENDIAN )
        swap_image( my_image , xsize, ysize, maxval);


printf("xsize=%d\nysize=%d\n" , xsize , ysize);


/* image pixels: from pointer to matrix */

unsigned short int image_matrix[xsize][ysize];

k = 0;
for (int i = 0 ; i < ysize ; i++)
	for (int j = 0 ; j < xsize ; j++)
		image_matrix[i][j] = my_image[k++]; 



/* CHECK: show some pixel values */ 

print_from = atoi (* (argv + 4) );
print_to = atoi (* (argv + 5) );

printf("AFTER READ:  \n");
for (int i = 0 ; i < 4 ; i++ ) {
        printf("Row %d , elements from %d to %d :\n" , i , print_from , print_to);
        for (int j = print_from + xsize*i ; j < print_to + 1 + xsize*i ; j++) {
                printf("%7d  " , my_image[j]) ;
        }
        printf("\n");
}
printf("\n");



/* blur the image */

float * blurred_image;
blurred_image = (float *) calloc (xsize*ysize , sizeof (float));


for (int i=0 ; i<ysize ; i++) {
	for (int j=0 ; j<xsize ; j++) {
        	for (int m=i-s , p=0 ; m<=i+s ; m++ , p++) {
               	for (int n=j-s , q=0 ; n<=j+s ; n++ , q++) {
                		if (m>=0 & m<ysize & n>=0 & n<xsize)
                    			blurred_image[i*xsize+j] += image_matrix[m][n] * kernel_matrix[p][q];
            		}
        	}
    	}
}

free(kernel);



/* CHECK: print some floating-point pixel values after blurring */

printf("\nAFTER BLURRING:\n");
for (int i = 0 ; i < 4 ; i++) {
        printf("Row %d , elements from %d to %d :\n" , i , print_from , print_to);
        for (int j = print_from ; j < print_to + 1 ; j++) {
                printf("%7.1f  " , blurred_image[i*xsize+j] );                
        }
        printf("\n");
}
printf("\n");


/* check if values are within the limit (65535), set those which exceed the limit to 65535 and convert all values from float to integer */

float threshold = 65535;
        
for (int i = 0 ; i < xsize*ysize ; i++)
	my_image[i] = (blurred_image[i] <= threshold) ? blurred_image[i] : threshold;

free (blurred_image);




/* write the new image */

if ( I_M_LITTLE_ENDIAN )
        swap_image( my_image , xsize, ysize, maxval);


write_pgm_image (my_image , maxval , xsize , ysize , "IMAGE.pgm");



/* free memory space required by used pointers */
free(my_image);


return 0;
}

