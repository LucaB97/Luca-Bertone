#include <stdio.h>
#include <stdlib.h>

#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) +	\
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif


void generate_kernel (float * kernel_ptr , const int type , const int dimension , const float weight)
{
	switch (type) {
		case 0:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				kernel_ptr[i] = 1 / (float)(dimension*dimension);
			}
			break;
                
		case 1:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				if (i != (((dimension*dimension-1)/2)))
					kernel_ptr[i] = (1-weight)/(dimension*dimension-1);
				else
					kernel_ptr[i] = weight;
			}
	}
}



void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}



void blurring (float * new_ptr , const short int * old_ptr , const float * kernel_ptr , const int x_size , const int y_size , const int half_kernel)
{
	int current_index;

	for ( int new_element = 0 ; new_element < x_size*y_size ; new_element++ ) 
{
   		new_ptr[new_element] = 0;
   		current_index = new_element - half_kernel*x_size - half_kernel;
   		int i = 0;
   
   		for (int rows = -half_kernel ; rows <= half_kernel ; rows++) {
      
      			int row_middle = new_element+rows*x_size;
      			if (row_middle<0)
         			row_middle += half_kernel*x_size+1;

      			for (int columns = -half_kernel ; columns <= half_kernel ; columns++) {         
         			if (current_index >= 0 & current_index < x_size*y_size & (current_index / x_size) == ((row_middle ) / x_size))
            				new_ptr[new_element] += old_ptr[current_index] * kernel_ptr[i];
         			++current_index;
         			++i;
      			}
      			current_index += x_size - (2*half_kernel+1);
   		}
	}
}



void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;
}




int main(int argc , char **argv ) {

int maxval , xsize , ysize , kernel_type , kernel_dimension , s; 
float kernel_weight;


float * blurred_image;
float * kernel;
short int * my_image;
void * my_pointer = &my_image;



/* take inputs and generate the kernel */
if (argc > 2) {
	kernel_type = atoi ( *(argv + 1) );
	if (kernel_type == 0 | kernel_type == 1 | kernel_type == 2) {
		kernel_dimension = atoi ( *(argv + 2) );
		if (kernel_dimension % 2 == 0) {
			printf("The kernel dimension you entered is a even number (%d), but a odd number is required: %d + 1 = %d will be used.\n" , kernel_dimension , kernel_dimension , kernel_dimension + 1);
			++kernel_dimension; 
		}
		s = (kernel_dimension-1)/2; 
	}
	else 
		printf("Admissable values for kernel type are: 0=mean kernel , 1=weighted kernel , 2=gaussian kernel\n");
	
	if (kernel_type == 1) {
		if (argc > 3) {
			kernel_weight = atof ( *(argv+3) );
			if (kernel_weight < 0 | kernel_weight > 1) {
				printf("You entered a weight which is out of the range (0,1). The default value of 1/(kernel_dimension^2) will be used.\n");
				kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
			}
		}
		else {
			printf("You did not specify a weight for central element of the Weighted kernel. The default value of 1/(kernel_dimension^2) will be used.\n");
			kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
		}
	}

kernel = (float *) calloc (kernel_dimension*kernel_dimension , sizeof(float) );
generate_kernel (kernel , kernel_type , kernel_dimension , kernel_weight);

}
else {
	printf("You should enter at least two values: one for kernel type and one for its dimension.\n");
}



/* read the image */
read_pgm_image(my_pointer , &maxval , &xsize , &ysize , "check_me.pgm");

if ( I_M_LITTLE_ENDIAN )
	swap_image( ptr, xsize, ysize, maxval);



/* blur the image */
blurred_image = (float*)calloc( xsize*ysize, sizeof(float) );

blurring (blurred_image , my_image , kernel , xsize , ysize , s);



/* write the new image */

if ( I_M_LITTLE_ENDIAN )
	swap_image( ptr, xsize, ysize, maxval);

write_pgm_image (&blurred_image , maxval , xsize , ysize , "IMAGE.pgm");

return 0;
}

