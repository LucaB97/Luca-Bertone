#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include <mpi.h>
#define USE MPI

#if ((0x100 & 0xf) == 0x0)
#define I_M_LITTLE_ENDIAN 1
#define swap(mem) (( (mem) & (short int)0xff00) >> 8) + \
  ( ((mem) & (short int)0x00ff) << 8)
#else
#define I_M_LITTLE_ENDIAN 0
#define swap(mem) (mem)
#endif



void generate_kernel (double * kernel_ptr , const int type , const int dimension , const float weight)
{
	switch (type) {
		case 0:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				kernel_ptr[i] = 1 / (double)(dimension*dimension)
;
			}
			break;
                
		case 1:
			for (int i = 0 ; i < dimension*dimension ; i++) {
				if (i != (((dimension*dimension-1)/2)))
					kernel_ptr[i] = (1-weight)/(dimension*dimension-1);
				else
					kernel_ptr[i] = weight;
			}
	}
}



void read_pgm_image( void **image, int *maxval, int *xsize, int *ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "r"); 

  *image = NULL;
  *xsize = *ysize = *maxval = 0;
  
  char    MagicN[2];
  char   *line = NULL;
  size_t  k, n = 0;
  
  // get the Magic Number
  k = fscanf(image_file, "%2s%*c", MagicN );

  // skip all the comments
  k = getline( &line, &n, image_file);
  while ( (k > 0) && (line[0]=='#') )
    k = getline( &line, &n, image_file);

  if (k > 0)
    {
      k = sscanf(line, "%d%*c%d%*c%d%*c", xsize, ysize, maxval);
      if ( k < 3 )
	fscanf(image_file, "%d%*c", maxval);
    }
  else
    {
      *maxval = -1;         // this is the signal that there was an I/O error
			    // while reading the image header
      free( line );
      return;
    }
  free( line );
  
  int color_depth = 1 + ( *maxval > 255 );
  unsigned int size = *xsize * *ysize * color_depth;
  
  if ( (*image = (char*)malloc( size )) == NULL )
    {
      fclose(image_file);
      *maxval = -2;         // this is the signal that memory was insufficient
      *xsize  = 0;
      *ysize  = 0;
      return;
    }
  
  if ( fread( *image, 1, size, image_file) != size )
    {
      free( image );
      image   = NULL;
      *maxval = -3;         // this is the signal that there was an i/o error
      *xsize  = 0;
      *ysize  = 0;
    }  

  fclose(image_file);
  return;
}



void swap_image( void *image, int xsize, int ysize, int maxval )
/*
 * This routine swaps the endianism of the memory area pointed
 * to by ptr, by blocks of 2 bytes
 *
 */
{
  if ( maxval > 255 )
    {
      // pgm files has the short int written in
      // big endian;
      // here we swap the content of the image from
      // one to another
      //
      unsigned int size = xsize * ysize;
      for ( int i = 0; i < size; i++ )
        ((unsigned short int*)image)[i] = swap(((unsigned short int*)image)[i]);
    }
  return;
}



void write_pgm_image( void *image, int maxval, int xsize, int ysize, const char *image_name)
{
  FILE* image_file; 
  image_file = fopen(image_name, "w"); 

  int color_depth = 1 + ( maxval > 255 );

  fprintf(image_file, "P5\n# generated by\n# put here your name\n%d %d\n%d\n", xsize, ysize, maxval);
  
  // Writing file
  fwrite( image, 1, xsize*ysize*color_depth, image_file);  

  fclose(image_file); 
  return ;
}


void* blur_image(double* blurred_image, int myid, int xsize, int ysize, int s, int numprocs, double* kernel, int kernel_dimension, unsigned short int* my_image) {
	for(int i=0; i<ysize; i++) {
		for(int j=myid*(xsize/numprocs); j<(myid+1)*(xsize/numprocs); j++) {
                        for (int m=i-s , p=0 ; m<=i+s ; m++ , p++) {  
				for (int n=j-s , q=0 ; n<=j+s ; n++ , q++) { 
					if (m>=0 & m<ysize & n>=0 & n<xsize)
						blurred_image[i*xsize+j] += my_image[m*xsize+n] * kernel[p*kernel_dimension+q]; 
				}      
			}  
		}
	}
}


/*
void blur_image (double * blurred , const unsigned short int * image , const int xsize , const int ysize , const double * kernel_ptr , const int half_kernel , const int kernel_dim , int proc_id , const int procs_num)
{


for (int i=proc_id*ysize/procs_num ; i<(proc_id+1)*ysize/procs_num-1 ; i++) {
	for (int j=0 ; j<xsize ; j++) {
        	for (int m=i-half_kernel , p=0 ; m<=i+half_kernel ; m++ , p++) {
               	for (int n=j-half_kernel , q=0 ; n<=j+half_kernel ; n++ , q++) {
                		if (m>=0 & m<ysize & n>=0 & n<xsize)
                    			blurred[i*xsize+j] += image[m*xsize+n] * kernel_ptr[p*kernel_dim+q];
            		}
        	}
    	}
}

return;
}
*/




int main(int argc , char **argv ) {


/* declarations */

int maxval , xsize , ysize , kernel_type , kernel_dimension , s; 

float kernel_weight;

double * kernel;

char * input_file;
char * output_file;

int myid, numprocs;
int master = 0;
int tag = 123;
                                                                                     
MPI_Init(&argc,&argv);                                                         
MPI_Comm_size(MPI_COMM_WORLD,&numprocs);                                       
MPI_Comm_rank(MPI_COMM_WORLD,&myid);     

MPI_Status status;
MPI_Request request;


// take inputs and generate the kernel 
if (argc > 5) {
	kernel_type = atoi (argv[1]);
	if (kernel_type == 0 | kernel_type == 1 | kernel_type == 2) {
		kernel_dimension = atoi (argv[2]);
		if (kernel_dimension % 2 == 0) {
			printf("The kernel dimension you entered is a even number (%d), but a odd number is required: %d + 1 = %d will be used.\n\n" , kernel_dimension , kernel_dimension , kernel_dimension + 1);
			++kernel_dimension; 
		}
		s = (kernel_dimension-1)/2; 
	}
	else { 
		printf("Admissable values for kernel type (first value to be entered) are:\n0=mean kernel\n1=weighted kernel\n2=gaussian kernel\n\n");
		return 0;
	}
	
	if (kernel_type == 1) {
		if (argc > 3) {
			kernel_weight = atof (argv[3]);
			if (kernel_weight < 0 | kernel_weight > 1) {
				printf("You entered a weight which is out of the range (0,1). The default value of 1/(kernel_dimension^2) will be used.\n\n");
				kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
			}
		}
		else {
			printf("You did not specify a weight for central element of the Weighted kernel. The default value of 1/(kernel_dimension^2) will be used.\n\n");
			kernel_weight = 1/(float)(kernel_dimension*kernel_dimension);
		}
	}

	kernel = (double *) calloc (kernel_dimension*kernel_dimension , sizeof(double) );
	generate_kernel (kernel , kernel_type , kernel_dimension , kernel_weight);

	input_file = argv[4];
	output_file = argv[5];
}
else {
	printf("You should enter:\na value (integer) for the kernel type,\na value (integer) for kernel dimension,\na value (floating-point) for the weight (for mean and gaussian kernel, put 0),\nthe name of the input file,\nthe name of the output file.\n\n");
        MPI_Finalize();
	exit(-1);
}


// read the image 

unsigned short int * my_image;
void * my_pointer = &my_image;

if(myid == 0) {

read_pgm_image(my_pointer , &maxval , &xsize , &ysize , input_file);

if ( I_M_LITTLE_ENDIAN )
        swap_image( my_image , xsize, ysize, maxval);

}

MPI_Bcast( &xsize, 1, MPI_INT, 0, MPI_COMM_WORLD);
MPI_Bcast( &ysize, 1, MPI_INT, 0, MPI_COMM_WORLD);

//send to each processor a part of the original problem
int *sendcounts = (int*) calloc(numprocs,sizeof(int));
int *displs = (int*)calloc(numprocs,sizeof(int));
int rem = (xsize*ysize)%numprocs; 
int sum = 0;

for(int i=0; i<numprocs; i++) {
	sendcounts[i] = ((xsize*ysize)/numprocs);
	if (rem>0) {
		sendcounts[i]++;
		rem--;
	}
	displs[i]=sum;
	sum += sendcounts[i];
}

unsigned short int* recbuff = (unsigned short int *) calloc (sendcounts[myid] , sizeof(unsigned short int) );


MPI_Scatterv(my_image, sendcounts, displs, MPI_UNSIGNED_SHORT, recbuff , sendcounts[myid], MPI_UNSIGNED_SHORT, 0, MPI_COMM_WORLD );





//define the number of blocks needed from each side of the current one, in order to make computations
int halo_blocks;
if (s % (ysize/numprocs) != 0)
	halo_blocks = s/(ysize/numprocs)+1;
else 
	halo_blocks = s/(ysize/numprocs);



int *my_block_dimension = (int*) calloc(numprocs,sizeof(int));  //the specific dimension of the block associated with a certain core (see below**)
int *starting_point = (int*) calloc(numprocs,sizeof(int));   //an index to denote the point from which data to be blurred for each core are to be stored in the block (see below**)

for (int i = -halo_blocks ; i <= halo_blocks ; i++) {
	if (myid+i >= 0 & myid+i < numprocs) {
		my_block_dimension[myid] += sendcounts[myid+i];
		if (i < 0)
		starting_point[myid] += sendcounts[myid+i];
	}
}

unsigned short int * my_block = (unsigned short int *) calloc (my_block_dimension[myid] , sizeof(unsigned short int));   //(**)define a new pointer for each process, in which both the halos and the data to be modified will be stored



//place data from recbuff in the proper positions in my_block

for (int i = 0 ; i < sendcounts[myid] ; i++) {
	counter = starting_point[myid];
	my_block[counter++] = recbuff[i];
}



// creating the halo: sending from each core data to each core that needs them for the blurring computation based on halo_blocks (example: core 2 sends its data to core 0,1,3,4 if the halo blocks = 2)

int counter;

for (int i = 0 ; i < numprocs ; i++) {
	counter = 0;
	for (int j = i - halo_blocks ; j = i + halo_blocks ; j++) {

		if (j >= 0 & j < numprocs) {
			if (j != i) {
				if (myid == i)
					MPI_Send (recbuff , sendcounts[i] , MPI_UNSIGNED_SHORT , j , 123 , MPI_COMM_WORLD);
				else if (myid == j)
					MPI_Recv (&my_block[counter] , sendcounts[i] , MPI_UNSIGNED_SHORT , i , 123 , MPI_COMM_WORLD , &status); 
			} 
			counter += sendcounts[j];
		}
}



/*
double * blurred_image;
blurred_image = (double *) calloc (xsize*ysize , sizeof (double));

for (int i= ; i<ysize/numprocs ; i++) {
	for (int j=0 ; j<xsize ; j++) {
        	for (int m=i-s , p=0 ; m<=i+s ; m++ , p++) {
               	for (int n=j-s , q=0 ; n<=j+s ; n++ , q++) {
                		if (m>=0 & m<ysize/numprocs & n>=0 & n<xsize)
                    			blurred_image[i*xsize+j] += recbuff[m*xsize+n] * kernel[p*kernel_dimension+q];
            		}
        	}
    	}
}

free(kernel);



// check if values are within the limit (65535), set those which exceed the limit to 65535 and convert all values from float to integer

float threshold = 65535;
        
for (int i = 0 ; i < xsize*ysize/numprocs ; i++)
	recbuff[i] = (blurred_image[i] <= threshold) ? blurred_image[i] : threshold;

free (blurred_image);


// write the new image


MPI_Gatherv (recbuff , sendcounts[myid] , MPI_UNSIGNED_SHORT , my_image , sendcounts , displs , MPI_UNSIGNED_SHORT , 0 , MPI_COMM_WORLD);


//if(myid==0) {

if ( I_M_LITTLE_ENDIAN )
        swap_image( my_image , xsize, ysize, maxval);

write_pgm_image (my_image , maxval , xsize , ysize , output_file);


//free(my_image);
//}
*/
MPI_Finalize();




return 0;
}
